import{_ as o,c as t,a5 as i,o as a}from"./chunks/framework.HLuILII-.js";const h=JSON.parse('{"title":"What is a RegionGrid?","description":"","frontmatter":{},"headers":[],"relativePath":"regiongrids/intro.md","filePath":"regiongrids/intro.md","lastUpdated":null}'),d={name:"regiongrids/intro.md"};function r(n,e,s,c,l,g){return a(),t("div",null,e[0]||(e[0]=[i('<h1 id="What-is-a-RegionGrid?" tabindex="-1">What is a RegionGrid? <a class="header-anchor" href="#What-is-a-RegionGrid?" aria-label="Permalink to &quot;What is a RegionGrid? {#What-is-a-RegionGrid?}&quot;">â€‹</a></h1><p>But how do we go from defining a GeoRegion, to <strong>extracting data</strong> for that GeoRegion? The answer is with the information in the <code>RegionGrid</code> types, which maps gridded lon-lat data to a given GeoRegion as follows:</p><ul><li><p>Mapping gridded lon-lat data to a <strong><code>RectRegion</code></strong> gives a <code>RectGrid</code> structure</p></li><li><p>Mapping gridded lon-lat data to a <strong><code>PolyRegion</code></strong> gives a <code>PolyGrid</code> structure</p></li><li><p>Mapping non-rectilinear gridded lon-lat data to a <strong><code>RegionMask</code></strong> gives a <code>RegionMask</code> structure</p></li></ul><p>However, the basic uses of <code>RectGrid</code> and <code>PolyGrid</code> are the same, and as such their differences are largely transparent to the user, except for one field found in <code>PolyGrid</code>, the <code>mask</code>, which will be elaborated upon later.</p><div class="warning custom-block"><p class="custom-block-title">Missing docstring.</p><p>Missing docstring for <code>RegionGrid</code>. Check Documenter&#39;s build log for details.</p></div><p>So basically a <code>RegionGrid</code> contains information on the indices of the gridded data that are part of the <code>GeoRegion</code>, thus helping us extract the relevant data for a given <code>GeoRegion</code>.</p>',6)]))}const u=o(d,[["render",r]]);export{h as __pageData,u as default};
